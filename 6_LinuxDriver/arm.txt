
1. ARM 基础
	用户模式(user)：用户程序的工作模式，运行在操作系统的用户态，不能操作其他硬件资源，只能执行处理自己的数据，也不能切换到其他模式，要切换到其他模式，只能产生中断或其他异常
	系统模式(system)：系统模式是特权模式，不受用户模式的限制。使用同一套寄存器。操作系统通过该模式使用户访问受限的资源
	一般中断模式(IRQ)： 用于处理一般的中断请求。一般在硬件产生中断信号后会自动进入该模式，是一种特权模式，可以自由访问系统硬件资源
	快速中断模式(FIQ)：用于处理时间要求比较紧急的中断请求。一般在高速数据传输及通道种
	管理模式(spuer visor)：一般CPU上电之后会自动进入该模式，该模式主要完成系统的初始化，软中断也会进入该模式。如果在用户模式下可以通过软中断进入该模式，请求访问硬件资源
	未定义模式(undefined)：未定义指令中止。CPU在指令的译码阶段不能识别该指令操作时，则会进入该模式
	终止模式非法访问(abort)：当用户非法访问内存，没有权限读写内存地址时，会进入该模式
	安全模式(monitor)：为了安全而扩展出来的用于执行安全监控代码的模式
	HYP：用于虚拟化扩展
	
		除了 User(USR)用户模式以外，其它 8 种运行模式都是特权模式。这几个运行模式可以通过软件进行任意切换，也可以通过中断或者异常来进行切换。大多数的程序都运行在用户模式，
	用户模式下是不能访问系统所有资源的，有些资源是受限的，要想访问这些受限的资源就必须进行模式切换。但是用户模式是不能直接进行切换的，用户模式下需要借助异常来完成模式切换，
	当要切换模式的时候，应用程序可以产生异常，在异常的处理过程中完成处理器模式切换。
		当中断或者异常发生以后，处理器就会进入到相应的异常模式种，每一种模式都有一组寄存器供异常处理程序使用，这样的目的是为了保证在进入异常模式以后，用户模式下的寄存器不会被破坏。

	ARM 架构提供了 16 个 32 位的通用寄存器(R0~R15)供软件使用，前 15 个(R0~R14)可以用作通用的数据存储，R13堆栈指针 SP, R14是链接寄存器 LR, R15是程序计数器 PC，用来保存将要执行的指令。
	ARM 还提供了一个当前程序状态寄存器 CPSR 和一个备份程序状态寄存器 SPSR， SPSR 寄存器就是 CPSR 寄存器的备份。
	R13 也叫做 SP，用来做为栈指针。基本上每种模式都有一个自己的 R13 物理寄存器，应用程序会初始化 R13，使其指向该模式专用的栈地址，这就是常说的初始化 SP 指针。
	LR 寄存器在 ARM 中主要用作如下两种用途：
		1、每种处理器模式使用 R14(LR)来存放当前子程序的返回地址，如果使用 BL 或者 BLX来调用子函数的话， R14(LR)被设置成该子函数的返回地址，在子函数中，将 R14(LR)中的值赋给 R15(PC)
		   即可完成子函数返回，	
		2、当异常发生以后，该异常模式对应的 R14 寄存器被设置成该异常模式将要返回的地址，R14 也可以当作普通寄存器使用。
		比如在子程序中可以使用如下代码：
			MOV PC, LR @寄存器 LR 中的值赋值给 PC，实现跳转
			或者可以在子函数的入口出将 LR 入栈：
			PUSH {LR} @将 LR 寄存器压栈
			在子函数的最后面出栈即可：
			POP {PC} @将上面压栈的 LR 寄存器数据出栈给 PC 寄存器，严格意义上来讲应该是将
					@LR-4 赋给 PC，因为 3 级流水线，这里只是演示代码。
	程序计数器 R15 也叫做 PC， R15 保存着当前执行的指令地址值加 8 个字节，这是因为 ARM的流水线机制导致的。 ARM 处理器 3 级流水线：取指->译码->执行，这三级流水线循环执行，
	比如当前正在执行第一条指令的同时也对第二条指令进行译码，第三条指令也同时被取出存放在 R15(PC)中。我们喜欢以当前正在执行的指令作为参考点，也就是以第一条指令为参考点，
	那么 R15(PC)中存放的就是第三条指令，换句话说就是 R15(PC)总是指向当前正在执行的指令地址再加上 2 条指令的地址。对于 32 位的 ARM 处理器，每条指令是 4 个字节，所以:
		R15 (PC)值 = 当前执行的程序位置 + 8 个字节。
	
	程序状态寄存器 CPSR
		N(bit31)：当两个补码表示的 有符号整数运算的时候， N=1 表示运算对的结果为负数， N=0表示结果为正数。
		Z(bit30)： Z=1 表示运算结果为零， Z=0 表示运算结果不为零，对于 CMP 指令， Z=1 表示进行比较的两个数大小相等。
		C(bit29)：在加法指令中，当结果产生了进位，则 C=1，表示无符号数运算发生上溢，其它情况下 C=0。在减法指令中，当运算中发生借位，则 C=0，表示无符号数运算发生下溢，其它情况下 C=1。
			对于包含移位操作的非加/减法运算指令， C 中包含最后一次溢出的位的数值，对于其它非加/减运算指令， C 位的值通常不受影响。
		V(bit28)： 对于加/减法运算指令，当操作数和运算结果表示为二进制的补码表示的带符号数时， V=1 表示符号位溢出，通常其他位不影响 V 位。
		Q(bit27)： 仅 ARM v5TE_J 架构支持，表示饱和状态， Q=1 表示累积饱和， Q=0 表示累积不饱和。
		IT[1:0](bit26:25)： 和 IT[7:2](bit15:bit10)一起组成 IT[7:0]，作为 IF-THEN 指令执行状态。
		J(bit24)： 仅 ARM_v5TE-J 架构支持， J=1 表示处于 Jazelle 状态，此位通常和 T(bit5)位一起表示当前所使用的指令集，如表 6.3.2.1 所示：
				J T 描述
				0 0 ARM
				0 1 Thumb
				1 1 ThumbEE
				1 0 Jazelle
		GE[3:0](bit19:16)： SIMD 指令有效，大于或等于。
		IT[7:2](bit15:10)： 参考 IT[1:0]。
		E(bit9)： 大小端控制位， E=1 表示大端模式， E=0 表示小端模式。
		A(bit8)： 禁止异步中断位， A=1 表示禁止异步中断。
		I(bit7)： I=1 禁止 IRQ， I=0 使能 IRQ。
		F(bit6)： F=1 禁止 FIQ， F=0 使能 FIQ。
		T(bit5)： 控制指令执行状态，表明本指令是 ARM 指令还是 Thumb 指令，通常和 J(bit24)一起表明指令类型，参考 J(bit24)位。
		M[4:0]： 处理器模式控制位
			10000 User 模式
			10001 FIQ 模式
			10010 IRQ 模式
			10011 Supervisor(SVC)模式
			10110 Monitor(MON)模式
			10111 Abort(ABT)模式
			11010 Hyp(HYP)模式
			11011 Undef(UND)模式
			11111 System(SYS)模式
